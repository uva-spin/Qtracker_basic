David's suggested refine_hit_arrays

def refine_hit_arrays(pred_mup, pred_mum, detectorIDs, elementIDs, softmax_mup, softmax_mum):
    import numpy as np
    N, NUM_DETECTORS = pred_mup.shape

    refined_mup = np.zeros_like(pred_mup, dtype=np.int32)
    refined_mum = np.zeros_like(pred_mum, dtype=np.int32)

    for i in range(N):
        det_ids_evt = np.array(detectorIDs[i], dtype=np.int32)
        elem_ids_evt = np.array(elementIDs[i], dtype=np.int32)

        for d in range(NUM_DETECTORS):
            softmax_sum_plus = np.sum(softmax_mup[i, d, :])
            softmax_sum_minus = np.sum(softmax_mum[i, d, :])

            if softmax_sum_plus >= softmax_sum_minus:
                assign_order = ['plus', 'minus']
            else:
                assign_order = ['minus', 'plus']

            assigned_elem = set()
            pred_elem = {'plus': pred_mup[i, d], 'minus': pred_mum[i, d]}

            for track in assign_order:
                pred = pred_elem[track]
                if pred == 0:
                    if track == 'plus': refined_mup[i, d] = 0
                    else: refined_mum[i, d] = 0
                    continue

                actual_elems = elem_ids_evt[det_ids_evt == (d+1)]
                candidates = [e for e in actual_elems if e not in assigned_elem]
                if len(candidates) == 0:
                    if track == 'plus': refined_mup[i, d] = 0
                    else: refined_mum[i, d] = 0
                    continue

                distances = np.abs(np.array(candidates) - pred)
                best = candidates[np.argmin(distances)]
                assigned_elem.add(best)
                if track == 'plus': refined_mup[i, d] = best
                else: refined_mum[i, d] = best

    return refined_mup, refined_mum
